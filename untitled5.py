# -*- coding: utf-8 -*-
"""Untitled5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1u_rlKDq7MVaSdsNeNrrKDzoJDC6KAsYr
"""

from collections import deque

# Process info: [PID, Arrival Time, Burst Time]
processes = [
    ['P1', 0, 5],
    ['P2', 1, 3],
    ['P3', 2, 1],
    ['P4', 3, 2],
    ['P5', 4, 3]
]

time_quantum = 2

# Sort processes by arrival time
processes.sort(key=lambda x: x[1])

n = len(processes)
remaining_bt = [p[2] for p in processes]
completion_time = [0] * n
arrival_time = [p[1] for p in processes]
waiting_time = [0] * n
turnaround_time = [0] * n

ready_queue = deque()
time = 0
visited = [False] * n
process_map = {p[0]: i for i, p in enumerate(processes)}

# Add first arrived process
while True:
    for i in range(n):
        if arrival_time[i] <= time and not visited[i]:
            ready_queue.append(i)
            visited[i] = True
    if ready_queue:
        break
    time += 1

# Round Robin Execution
while ready_queue:
    idx = ready_queue.popleft()

    exec_time = min(time_quantum, remaining_bt[idx])
    time += exec_time
    remaining_bt[idx] -= exec_time

    # Add new processes arrived during execution
    for i in range(n):
        if arrival_time[i] <= time and not visited[i]:
            ready_queue.append(i)
            visited[i] = True

    # Re-add process if it's not finished
    if remaining_bt[idx] > 0:
        ready_queue.append(idx)
    else:
        completion_time[idx] = time

# Calculate TAT and WT
for i in range(n):
    turnaround_time[i] = completion_time[i] - arrival_time[i]
    waiting_time[i] = turnaround_time[i] - processes[i][2]

# Output
print("PID\tAT\tBT\tCT\tTAT\tWT")
for i in range(n):
    print(f"{processes[i][0]}\t{arrival_time[i]}\t{processes[i][2]}\t{completion_time[i]}\t{turnaround_time[i]}\t{waiting_time[i]}")

# Averages
avg_tat = sum(turnaround_time) / n
avg_wt = sum(waiting_time) / n
print(f"\nAverage Turnaround Time: {avg_tat}")
print(f"Average Waiting Time: {avg_wt}")